<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple Driving Game</title>
  <style>
    html, body { margin: 0; height: 100%; background:#0b0f14; color:#e8eef7; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:12px; }
    canvas { background:#111826; border:1px solid #243045; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .hud { width: min(920px, 95vw); display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .pill { background:#121a29; border:1px solid #243045; padding:8px 10px; border-radius:999px; font-size:14px; }
    .hint { opacity:.85; font-size:13px; }
    button { cursor:pointer; border-radius:10px; border:1px solid #243045; background:#121a29; color:#e8eef7; padding:8px 10px; }
    button:hover { filter:brightness(1.1); }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="hud">
      <div class="pill" id="stat">Speed: 0 | Score: 0 | HP: 100</div>
      <div class="pill hint">Controls: W/A/S/D or ↑/←/↓/→ • Space = Handbrake • R = Restart</div>
      <button id="restart">Restart</button>
    </div>

    <canvas id="game" width="900" height="540"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const statEl = document.getElementById("stat");
  const restartBtn = document.getElementById("restart");

  // ---------- Game constants ----------
  const W = canvas.width, H = canvas.height;

  // Road is "infinite" vertically; we just scroll lane markers.
  const road = {
    x: W * 0.5,
    width: 420,
    laneCount: 3,
    markerGap: 42,
    markerLen: 24,
    scroll: 0
  };

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    keys.add(e.code);
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    if (e.code === "KeyR") reset();
  }, { passive:false });
  window.addEventListener("keyup", (e) => keys.delete(e.code));

  // ---------- Entities ----------
  const player = {
    x: road.x,
    y: H * 0.78,
    w: 34,
    h: 64,
    angle: 0,       // visual tilt
    vx: 0,
    speed: 0,       // forward speed (road scroll)
    hp: 100,
    invuln: 0       // frames of invulnerability after hit
  };

  let obstacles = [];
  let particles = [];
  let score = 0;
  let gameOver = false;

  function spawnObstacle() {
    // pick a lane center
    const laneW = road.width / road.laneCount;
    const lane = Math.floor(Math.random() * road.laneCount);
    const laneCenter = (road.x - road.width/2) + laneW*lane + laneW/2;

    // obstacle sizes / types
    const type = Math.random() < 0.75 ? "cone" : "car";
    const w = type === "cone" ? 22 : 38;
    const h = type === "cone" ? 28 : 70;

    obstacles.push({
      x: laneCenter + (Math.random()*12 - 6),
      y: -h - 10,
      w, h,
      type,
      passed: false
    });
  }

  function addParticles(x,y,n=10) {
    for (let i=0;i<n;i++){
      particles.push({
        x, y,
        vx: (Math.random()*2-1)*2.3,
        vy: (Math.random()*2-1)*2.3,
        life: 30 + Math.random()*25
      });
    }
  }

  // ---------- Collision ----------
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ---------- Reset ----------
  function reset(){
    obstacles = [];
    particles = [];
    score = 0;
    gameOver = false;

    player.x = road.x;
    player.vx = 0;
    player.speed = 0;
    player.angle = 0;
    player.hp = 100;
    player.invuln = 0;

    road.scroll = 0;

    // seed a few obstacles
    for (let i=0;i<4;i++){
      spawnObstacle();
      obstacles[obstacles.length-1].y = -140 * (i+1);
    }
  }
  restartBtn.addEventListener("click", reset);

  // ---------- Update ----------
  let last = performance.now();
  let spawnTimer = 0;

  function update(dt){
    if (gameOver) return;

    // Input
    const left  = keys.has("KeyA") || keys.has("ArrowLeft");
    const right = keys.has("KeyD") || keys.has("ArrowRight");
    const up    = keys.has("KeyW") || keys.has("ArrowUp");
    const down  = keys.has("KeyS") || keys.has("ArrowDown");
    const handbrake = keys.has("Space");

    // Speed model
    const accel = up ? 520 : 0;
    const brake = down ? 620 : 0;
    const drag = 220;

    // forward speed affects road scroll + obstacle movement
    player.speed += (accel - brake - drag) * dt;
    if (!up && !down) player.speed += (-Math.sign(player.speed) * 140) * dt; // gentle auto-slow
    player.speed = clamp(player.speed, -120, 780);

    // steering strength depends on speed (harder to turn at low speed)
    const speedFactor = clamp(Math.abs(player.speed)/600, 0.25, 1);
    const steer = (right ? 1 : 0) - (left ? 1 : 0);
    const steerAccel = 1200 * speedFactor;
    player.vx += steer * steerAccel * dt;

    // lateral friction (handbrake reduces friction => more drift)
    const lateralFric = handbrake ? 2.5 : 7.5;
    player.vx *= Math.exp(-lateralFric * dt);

    // apply lateral motion
    player.x += player.vx * dt;

    // road bounds (keep inside asphalt, allow a tiny shoulder)
    const halfRoad = road.width/2;
    const minX = road.x - halfRoad + player.w*0.7;
    const maxX = road.x + halfRoad - player.w*0.7;
    if (player.x < minX) { player.x = minX; player.vx *= -0.25; }
    if (player.x > maxX) { player.x = maxX; player.vx *= -0.25; }

    // visual tilt based on vx
    player.angle = lerp(player.angle, clamp(player.vx/520, -0.35, 0.35), 8*dt);

    // Scroll road (higher speed => more scroll)
    road.scroll += player.speed * dt;

    // Spawn obstacles faster as score increases
    spawnTimer += dt;
    const baseInterval = 0.9;
    const interval = clamp(baseInterval - score/2500, 0.42, baseInterval);
    if (spawnTimer >= interval){
      spawnTimer = 0;
      spawnObstacle();
    }

    // Move obstacles "down" relative to speed
    const obstacleSpeed = (player.speed + 240); // ensures things still move when speed small
    for (const o of obstacles){
      o.y += obstacleSpeed * dt;

      // scoring when you pass
      if (!o.passed && o.y > player.y + player.h){
        o.passed = true;
        score += (o.type === "cone" ? 10 : 25);
      }
    }
    // remove offscreen
    obstacles = obstacles.filter(o => o.y < H + 140);

    // collisions
    const px = player.x - player.w/2, py = player.y - player.h/2;
    if (player.invuln > 0) player.invuln -= dt;

    if (player.invuln <= 0){
      for (const o of obstacles){
        const ox = o.x - o.w/2, oy = o.y - o.h/2;
        if (aabb(px,py,player.w,player.h, ox,oy,o.w,o.h)){
          // hit
          player.invuln = 0.75; // seconds
          player.hp -= (o.type === "cone" ? 8 : 18);
          player.speed *= 0.72;
          player.vx *= -0.45;
          addParticles(player.x, player.y, 14);
          break;
        }
      }
    }

    // particles
    for (const p of particles){
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      p.life -= 60*dt;
    }
    particles = particles.filter(p => p.life > 0);

    // end
    if (player.hp <= 0){
      player.hp = 0;
      gameOver = true;
    }
  }

  // ---------- Draw ----------
  function draw(){
    // background
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0,0,W,H);

    // road
    const rx = road.x - road.width/2;
    ctx.fillStyle = "#1b2433";
    ctx.fillRect(rx, 0, road.width, H);

    // shoulders
    ctx.fillStyle = "#101726";
    ctx.fillRect(rx-30, 0, 30, H);
    ctx.fillRect(rx+road.width, 0, 30, H);

    // lane markers
    const laneW = road.width / road.laneCount;

    // solid borders
    ctx.strokeStyle = "#e8eef7";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(rx, 0); ctx.lineTo(rx, H);
    ctx.moveTo(rx+road.width, 0); ctx.lineTo(rx+road.width, H);
    ctx.stroke();

    // dashed lane dividers
    ctx.strokeStyle = "#c9d4e8";
    ctx.lineWidth = 2;
    for (let i=1; i<road.laneCount; i++){
      const x = rx + laneW*i;
      ctx.setLineDash([road.markerLen, road.markerGap]);
      ctx.lineDashOffset = -road.scroll;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // obstacles
    for (const o of obstacles){
      ctx.save();
      ctx.translate(o.x, o.y);

      if (o.type === "cone"){
        ctx.fillStyle = "#ffb02e";
        ctx.beginPath();
        ctx.moveTo(0, -o.h/2);
        ctx.lineTo(o.w/2, o.h/2);
        ctx.lineTo(-o.w/2, o.h/2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillRect(-o.w*0.35, 2, o.w*0.7, 4);
      } else {
        // car obstacle
        ctx.fillStyle = "#d04b4b";
        ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(-o.w/2 + 4, -o.h/2 + 8, o.w-8, 18); // windshield
        ctx.fillRect(-o.w/2 + 4, o.h/2 - 26, o.w-8, 18); // rear
        ctx.fillStyle = "#2a3347";
        ctx.fillRect(-o.w/2 - 4, -o.h/2 + 10, 6, 14);
        ctx.fillRect(o.w/2 - 2, -o.h/2 + 10, 6, 14);
        ctx.fillRect(-o.w/2 - 4, o.h/2 - 24, 6, 14);
        ctx.fillRect(o.w/2 - 2, o.h/2 - 24, 6, 14);
      }
      ctx.restore();
    }

    // particles (crash sparks)
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    for (const p of particles){
      ctx.globalAlpha = clamp(p.life/40, 0, 1);
      ctx.fillRect(p.x-1, p.y-1, 2, 2);
    }
    ctx.globalAlpha = 1;

    // player car
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);

    // blink when invulnerable
    if (player.invuln > 0 && Math.floor(performance.now()/80) % 2 === 0) {
      ctx.globalAlpha = 0.55;
    }

    ctx.fillStyle = "#4aa3ff";
    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-player.w/2 + 4, -player.h/2 + 10, player.w-8, 18);

    ctx.fillStyle = "#2a3347";
    ctx.fillRect(-player.w/2 - 4, -player.h/2 + 10, 6, 14);
    ctx.fillRect(player.w/2 - 2, -player.h/2 + 10, 6, 14);
    ctx.fillRect(-player.w/2 - 4, player.h/2 - 24, 6, 14);
    ctx.fillRect(player.w/2 - 2, player.h/2 - 24, 6, 14);

    ctx.restore();
    ctx.globalAlpha = 1;

    // HUD overlay: HP bar
    const barW = 240, barH = 12;
    const bx = 18, by = 18;
    ctx.fillStyle = "#121a29";
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = "#e8eef7";
    ctx.globalAlpha = 0.15;
    ctx.fillRect(bx, by, barW, barH);
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#e85d5d";
    ctx.fillRect(bx, by, barW * (player.hp/100), barH);
    ctx.strokeStyle = "#243045";
    ctx.strokeRect(bx, by, barW, barH);

    // Minimap
    const mw = 150, mh = 120;
    const mx = W - mw - 18, my = 18;
    ctx.fillStyle = "#121a29";
    ctx.fillRect(mx, my, mw, mh);
    ctx.strokeStyle = "#243045";
    ctx.strokeRect(mx, my, mw, mh);

    // map road
    const mapRoadW = mw * 0.6;
    const mapRoadX = mx + (mw - mapRoadW)/2;
    ctx.fillStyle = "#1b2433";
    ctx.fillRect(mapRoadX, my+6, mapRoadW, mh-12);

    // map player marker
    const pMapX = mapRoadX + (player.x - (road.x-road.width/2)) / road.width * mapRoadW;
    const pMapY = my + mh - 18;
    ctx.fillStyle = "#4aa3ff";
    ctx.fillRect(pMapX-3, pMapY-6, 6, 12);

    // map obstacles
    ctx.fillStyle = "#ffb02e";
    for (const o of obstacles){
      const oy = my + mh - 18 - ( (player.y - o.y) / 500 ) * (mh-28);
      if (oy < my+10 || oy > my+mh-10) continue;
      const ox = mapRoadX + (o.x - (road.x-road.width/2)) / road.width * mapRoadW;
      ctx.fillRect(ox-2, oy-2, 4, 4);
    }

    // Game over overlay
    if (gameOver){
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#e8eef7";
      ctx.textAlign = "center";
      ctx.font = "700 44px system-ui";
      ctx.fillText("Game Over", W/2, H/2 - 20);
      ctx.font = "400 18px system-ui";
      ctx.fillText("Press R or click Restart", W/2, H/2 + 18);
    }

    // Text stats
    const mph = Math.round(Math.abs(player.speed) * 0.12);
    statEl.textContent = `Speed: ${mph} | Score: ${score} | HP: ${player.hp}`;
  }

  // ---------- Loop ----------
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000); // cap dt
    last = now;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
