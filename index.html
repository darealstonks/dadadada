<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Driving Game</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background:#000; }
    #hud {
      position: fixed; left: 14px; bottom: 14px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #eaf2ff;
      background: rgba(10,14,22,.45);
      border: 1px solid rgba(160,180,255,.18);
      backdrop-filter: blur(8px);
      padding: 10px 12px;
      border-radius: 12px;
      min-width: 190px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      user-select: none;
    }
    #hud .big { font-size: 22px; font-weight: 800; letter-spacing: .3px; }
    #hud .small { font-size: 12px; opacity: .85; line-height: 1.4; }
    #hud .bar {
      margin-top: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.12);
      overflow: hidden;
    }
    #hud .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(120,210,255,.9), rgba(110,255,180,.95));
    }
    #help {
      position: fixed; top: 12px; left: 12px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(235,245,255,.92);
      background: rgba(10,14,22,.35);
      border: 1px solid rgba(160,180,255,.14);
      backdrop-filter: blur(6px);
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 360px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      user-select: none;
    }
    #help b { color: #fff; }
    #help .dim { opacity: .75; font-size: 12px; margin-top: 6px; line-height: 1.35; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="help">
    <div><b>Controls</b>: W / ↑ accelerate, S / ↓ brake/reverse, <b>A left</b>, <b>D right</b>, Space = handbrake</div>
    <div class="dim">Tip: hold W and steer into the curves. If you fly off-road, the car slows down.</div>
  </div>
  <div id="hud">
    <div class="big"><span id="mph">0</span> mph</div>
    <div class="small">Speed: <span id="ms">0.0</span> m/s · Gear: <span id="gear">N</span></div>
    <div class="bar"><div class="fill" id="speedFill"></div></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ---------- Renderer / Scene / Camera ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x9fb6ff, 0.0022);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 6, 14);

    // Sky-ish background
    scene.background = new THREE.Color(0x9fb6ff);

    // Lights
    const hemi = new THREE.HemisphereLight(0xdde8ff, 0x1b2440, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(40, 70, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 250;
    sun.shadow.camera.left = -120;
    sun.shadow.camera.right = 120;
    sun.shadow.camera.top = 120;
    sun.shadow.camera.bottom = -120;
    scene.add(sun);

    // Ground plane (far)
    const groundGeo = new THREE.PlaneGeometry(2000, 2000);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b6a3a, roughness: 1 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.02;
    ground.receiveShadow = true;
    scene.add(ground);

    // ---------- Input ----------
    const keys = new Set();
    window.addEventListener("keydown", (e) => keys.add(e.code));
    window.addEventListener("keyup", (e) => keys.delete(e.code));

    // ---------- Car (cooler looking) ----------
    const car = new THREE.Group();

    // Body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(2.0, 0.55, 4.2),
      new THREE.MeshStandardMaterial({ color: 0x1e5bff, metalness: 0.65, roughness: 0.25 })
    );
    body.castShadow = true;
    body.position.y = 0.65;
    car.add(body);

    // Cabin
    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(1.5, 0.55, 1.6),
      new THREE.MeshStandardMaterial({ color: 0x0d1020, metalness: 0.2, roughness: 0.15 })
    );
    cabin.castShadow = true;
    cabin.position.set(0, 0.98, -0.25);
    car.add(cabin);

    // Front splitter
    const splitter = new THREE.Mesh(
      new THREE.BoxGeometry(2.05, 0.08, 0.55),
      new THREE.MeshStandardMaterial({ color: 0x0b0e16, metalness: 0.3, roughness: 0.6 })
    );
    splitter.castShadow = true;
    splitter.position.set(0, 0.45, 1.9);
    car.add(splitter);

    // Wheels
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x151824, roughness: 0.95 });
    const wheelGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.3, 18);
    function makeWheel(x, z) {
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI / 2;
      w.position.set(x, 0.42, z);
      w.castShadow = true;
      return w;
    }
    const wheels = [
      makeWheel(-0.95,  1.45),
      makeWheel( 0.95,  1.45),
      makeWheel(-0.95, -1.45),
      makeWheel( 0.95, -1.45),
    ];
    wheels.forEach(w => car.add(w));

    car.position.set(0, 0, 0);
    scene.add(car);

    // ---------- Road / Map (endless with curves + hills) ----------
    const ROAD_HALF = 6.0;
    const SEG_LEN = 18;
    const SEG_COUNT = 90;

    // Canvas texture for lane markings
    const laneCanvas = document.createElement("canvas");
    laneCanvas.width = 256; laneCanvas.height = 1024;
    const ctx = laneCanvas.getContext("2d");
    ctx.fillStyle = "#2f3340"; ctx.fillRect(0,0,laneCanvas.width,laneCanvas.height);

    // edge lines + center dashed lines
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(24, 0); ctx.lineTo(24, laneCanvas.height);
    ctx.moveTo(laneCanvas.width-24, 0); ctx.lineTo(laneCanvas.width-24, laneCanvas.height);
    ctx.stroke();

    // dashed center lines (3 lanes feel)
    function dashedLine(x) {
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.lineWidth = 6;
      ctx.setLineDash([34, 26]);
      ctx.beginPath();
      ctx.moveTo(x, 0); ctx.lineTo(x, laneCanvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    dashedLine(laneCanvas.width * 0.5);
    dashedLine(laneCanvas.width * 0.5 - 42);
    dashedLine(laneCanvas.width * 0.5 + 42);

    const roadTex = new THREE.CanvasTexture(laneCanvas);
    roadTex.wrapS = THREE.RepeatWrapping;
    roadTex.wrapT = THREE.RepeatWrapping;
    roadTex.repeat.set(1, 6);

    const roadMat = new THREE.MeshStandardMaterial({
      map: roadTex,
      roughness: 1,
      metalness: 0
    });

    const roadGroup = new THREE.Group();
    scene.add(roadGroup);

    const segments = [];
    const segGeo = new THREE.PlaneGeometry(ROAD_HALF * 2, SEG_LEN, 1, 1);

    function makeSegment() {
      const m = new THREE.Mesh(segGeo, roadMat);
      m.rotation.x = -Math.PI / 2;
      m.receiveShadow = true;
      return m;
    }

    for (let i = 0; i < SEG_COUNT; i++) {
      const seg = makeSegment();
      roadGroup.add(seg);
      segments.push({
        mesh: seg,
        z: -i * SEG_LEN,
        x: 0,
        y: 0,
      });
    }

    // Road curvature function (smooth)
    let tCurve = 0;
    function roadOffset(z) {
      // z is negative forward. Use t based on distance.
      const s = (-z) * 0.015;
      // big gentle curves + small wobble
      return Math.sin(s * 0.7) * 7.0 + Math.sin(s * 2.1) * 1.7;
    }
    function roadHeight(z) {
      const s = (-z) * 0.012;
      return Math.sin(s * 0.9) * 1.2 + Math.sin(s * 0.23) * 2.3;
    }

    function updateSegments(carZ) {
      // move segments to stay ahead of car
      const minZ = carZ - (SEG_COUNT * SEG_LEN * 0.65);
      for (const s of segments) {
        if (s.z > carZ + SEG_LEN) {
          // behind the camera => move forward (more negative)
          s.z -= SEG_COUNT * SEG_LEN;
        } else if (s.z < minZ) {
          // too far ahead? (rare) pull back a bit
          s.z += SEG_COUNT * SEG_LEN;
        }
        const x = roadOffset(s.z);
        const y = roadHeight(s.z);
        s.mesh.position.set(x, y, s.z);
        s.mesh.rotation.z = (roadOffset(s.z - 2) - roadOffset(s.z + 2)) * 0.02; // banking feel
      }
    }

    // ---------- Background props (trees / buildings / mountains) ----------
    const deco = new THREE.Group();
    scene.add(deco);

    function rand(seed) { // tiny deterministic-ish random
      seed = Math.sin(seed) * 10000;
      return seed - Math.floor(seed);
    }

    function makeTree() {
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.18, 0.22, 1.2, 8),
        new THREE.MeshStandardMaterial({ color: 0x5a3a22, roughness: 1 })
      );
      trunk.position.y = 0.6;
      trunk.castShadow = true;

      const crown = new THREE.Mesh(
        new THREE.SphereGeometry(0.75, 10, 10),
        new THREE.MeshStandardMaterial({ color: 0x1f7a3a, roughness: 1 })
      );
      crown.position.y = 1.6;
      crown.castShadow = true;

      g.add(trunk, crown);
      return g;
    }

    function makeBuilding(h = 6) {
      const m = new THREE.Mesh(
        new THREE.BoxGeometry(3.2, h, 3.2),
        new THREE.MeshStandardMaterial({ color: 0x8d96aa, roughness: 0.95, metalness: 0.05 })
      );
      m.position.y = h / 2;
      m.castShadow = true;
      return m;
    }

    function makeMountain() {
      const m = new THREE.Mesh(
        new THREE.ConeGeometry(18, 22, 10),
        new THREE.MeshStandardMaterial({ color: 0x4a5f7a, roughness: 1 })
      );
      m.castShadow = false;
      m.receiveShadow = true;
      return m;
    }

    const props = [];
    const PROP_COUNT = 160;

    for (let i = 0; i < PROP_COUNT; i++) {
      const r = Math.random();
      let obj;
      if (r < 0.65) obj = makeTree();
      else obj = makeBuilding(4 + Math.random() * 18);

      const side = Math.random() < 0.5 ? -1 : 1;
      const distanceFromRoad = ROAD_HALF + 5 + Math.random() * 30;
      const z = -(i * 24) - 40 - Math.random() * 40;
      const baseX = side * distanceFromRoad;
      const x = baseX + (Math.random() - 0.5) * 6;

      obj.position.set(x, 0, z);
      deco.add(obj);
      props.push({ obj, z, side, dx: distanceFromRoad, jitter: (Math.random()-0.5)*6 });
    }

    // Big distant mountains
    const mountains = new THREE.Group();
    scene.add(mountains);
    for (let i = 0; i < 10; i++) {
      const m = makeMountain();
      m.position.set(-120 + i * 26, -2, -260 - (i % 3) * 60);
      m.rotation.y = i * 0.4;
      mountains.add(m);
    }

    function updateProps(carZ) {
      const forwardLimit = carZ - 650;  // far ahead (more negative)
      const behindLimit  = carZ + 80;   // behind camera
      for (const p of props) {
        // keep them aligned with the road's local offset, so scenery follows curves
        const roadX = roadOffset(p.obj.position.z);
        p.obj.position.x = roadX + p.side * p.dx + p.jitter;

        if (p.obj.position.z > behindLimit) {
          // move it forward
          p.obj.position.z -= 24 * PROP_COUNT;
        } else if (p.obj.position.z < forwardLimit) {
          // if it's too far forward, pull it back a bit (rare)
          p.obj.position.z += 24 * PROP_COUNT;
        }
      }
    }

    // ---------- Physics / Game Loop ----------
    let velocity = 0;          // m/s along forward direction (negative z)
    let steering = 0;          // -1..1
    let heading = 0;           // radians (car yaw relative to world z)
    let lateralVel = 0;        // sideways sliding
    let lastTime = performance.now();

    // Tuned for "not unbelievably slow"
    const cfg = {
      accel: 42,              // m/s^2
      brake: 58,              // m/s^2
      reverseAccel: 24,
      maxSpeed: 95,           // m/s (~213 mph)
      maxReverse: 22,
      steerRate: 2.8,         // how fast steering changes
      steerAtSpeed: 0.015,    // steering sensitivity drop with speed
      grip: 9.5,              // lateral damping
      drag: 0.7,              // air drag
      rolling: 1.4,           // rolling resistance
      offroadPenalty: 0.55,   // slows down off-road
    };

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // HUD
    const mphEl = document.getElementById("mph");
    const msEl = document.getElementById("ms");
    const gearEl = document.getElementById("gear");
    const fillEl = document.getElementById("speedFill");

    function updateHUD() {
      const mph = Math.abs(velocity) * 2.236936;
      mphEl.textContent = Math.round(mph).toString();
      msEl.textContent = Math.abs(velocity).toFixed(1);
      let gear = "N";
      if (velocity > 1) gear = "D";
      else if (velocity < -1) gear = "R";
      gearEl.textContent = gear;

      const pct = clamp(Math.abs(velocity) / cfg.maxSpeed, 0, 1) * 100;
      fillEl.style.width = pct.toFixed(1) + "%";
    }

    function isOffRoad(carX, carZ) {
      const centerX = roadOffset(carZ);
      const dx = carX - centerX;
      return Math.abs(dx) > (ROAD_HALF - 0.6);
    }

    function animate() {
      const now = performance.now();
      let dt = (now - lastTime) / 1000;
      lastTime = now;
      dt = Math.min(dt, 0.033); // avoid huge jumps

      // Input (A/D fixed properly)
      const forward = keys.has("KeyW") || keys.has("ArrowUp");
      const back = keys.has("KeyS") || keys.has("ArrowDown");
      const left = keys.has("KeyA") || keys.has("ArrowLeft");
      const right = keys.has("KeyD") || keys.has("ArrowRight");
      const handbrake = keys.has("Space");

      // Steering smoothing
      const targetSteer = (left ? -1 : 0) + (right ? 1 : 0);
      steering += (targetSteer - steering) * clamp(cfg.steerRate * dt, 0, 1);
      steering = clamp(steering, -1, 1);

      // Throttle / brake
      if (forward) {
        velocity += cfg.accel * dt;
      } else if (back) {
        if (velocity > 2) velocity -= cfg.brake * dt;
        else velocity -= cfg.reverseAccel * dt;
      }

      // Drag + rolling resistance
      const sign = Math.sign(velocity);
      const drag = cfg.drag * velocity * velocity * sign; // quadratic drag
      velocity -= drag * dt;

      // rolling resistance toward 0
      const rr = cfg.rolling * dt;
      if (Math.abs(velocity) < rr) velocity = 0;
      else velocity -= rr * Math.sign(velocity);

      // Clamp speeds
      velocity = clamp(velocity, -cfg.maxReverse, cfg.maxSpeed);

      // Off-road slows you down + less grip
      const offroad = isOffRoad(car.position.x, car.position.z);
      if (offroad) velocity *= Math.pow(cfg.offroadPenalty, dt * 8);

      // Turning rate depends on speed (less twitchy at high speed)
      const speedAbs = Math.abs(velocity);
      const steerEffect = steering / (1 + speedAbs * cfg.steerAtSpeed);
      heading += steerEffect * (0.95 + speedAbs * 0.015) * dt;

      // Lateral dynamics (simple drift)
      lateralVel += Math.sin(heading) * velocity * 0.002; // small coupling
      const grip = (offroad ? cfg.grip * 0.55 : cfg.grip);
      lateralVel -= lateralVel * grip * dt;

      // Handbrake = more slide + slower
      if (handbrake && speedAbs > 6) {
        lateralVel += steering * 8 * dt;
        velocity *= Math.pow(0.985, dt * 60);
      }

      // Road-following: car tries to follow road curve (helps you stay centered)
      const roadX = roadOffset(car.position.z);
      const roadY = roadHeight(car.position.z);
      const centerPull = (roadX - car.position.x) * 0.22;
      car.position.x += centerPull * dt * (offroad ? 0.35 : 1.0);

      // Move forward (negative z)
      // Heading affects lateral x movement. Keep it arcadey & controllable.
      const forwardMove = velocity * dt;
      car.position.z -= Math.cos(heading) * forwardMove;
      car.position.x += Math.sin(heading) * forwardMove;
      car.position.x += lateralVel * dt;

      // Keep car hovering slightly above road height
      car.position.y = roadY;

      // Rotate car to heading + small banking
      car.rotation.y = heading;
      car.rotation.z = -steering * clamp(speedAbs / 50, 0, 1) * 0.08;

      // Wheel spin
      const wheelSpin = forwardMove * 1.25;
      wheels.forEach(w => w.rotation.x -= wheelSpin);

      // Update world
      updateSegments(car.position.z);
      updateProps(car.position.z);

      // Chase camera (smooth)
      const camBack = 12;
      const camUp = 6.5;
      const lookAhead = 16;

      const desiredCam = new THREE.Vector3(
        car.position.x - Math.sin(heading) * camBack,
        car.position.y + camUp,
        car.position.z + Math.cos(heading) * camBack
      );
      camera.position.lerp(desiredCam, 1 - Math.pow(0.001, dt));

      const desiredLook = new THREE.Vector3(
        car.position.x + Math.sin(heading) * 0.0,
        car.position.y + 1.2,
        car.position.z - lookAhead
      );
      camera.lookAt(desiredLook);

      updateHUD();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Start
    updateSegments(car.position.z);
    updateProps(car.position.z);
    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    });
  </script>
</body>
</html>
